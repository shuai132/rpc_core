# RpcCore

[![Build Status](https://github.com/shuai132/RpcCore/workflows/build/badge.svg)](https://github.com/shuai132/RpcCore/actions?workflow=build)

a tiny rpc library, support all platform, even microchips.

## Introduction

The complete RPC frameworks (such as `gRPC` and `brpc`) have complex functions
and are not practical for use in embedded platforms.

This project offers a lightweight and user-friendly implementation that is better suited for one-to-one RPC calls.

It supports a wide range of microchips, including Arduino, STM32, ESP32/ESP8266, and more.

Note:
This project solely offers the protocol layer and API,
and `does not include the implementation of the transport layer`.
For TCP-based implementations, please refer to the Links section located at the end of the document.

## Features

* Header-Only
* No need to define a schema
* Supports performance-limited platforms, including MCUs
* Compatible with any connection type (serial port, TCP, etc.)
* RAII-based Dispose for automatic request cancellation
* Timeout and retry settings
* Supports `std::future` interface
* Customizable message types with implementations for `Flatbuffers` and `JSON`

## Requirements

* C++11
* Complete data packets are required for data transmission, such as in WebSocket.  
  If using socket/serial port, etc.,
  message packing and unpacking need to be implemented by yourself. You can use:
  [PacketProcessor](https://github.com/shuai132/PacketProcessor)
  or
  [data_packer.hpp](https://github.com/shuai132/esp_rpc/blob/main/data_packer.hpp)

## Usage

```c++
// The Receiver
rpc->subscribe("cmd", [](const String& msg) -> String {
    assert(msg == "hello");
    return "world";
});

// The Sender
rpc->cmd("cmd")
    ->msg(String("hello"))
    ->rsp([](const String& rsp) {
      assert(rsp == "world");
    })
    ->call();
```

Detailed initialization process and unit tests can be found at: [RpcTest.cpp](test/RpcTest.cpp)

## Plugin

* [FlatbuffersMsg.hpp](./plugin/FlatbuffersMsg.hpp)  
  Supports using types generated by `Flatbuffers` directly as message  
  (add the option `--gen-object-api` when using `flatc`)


* [JsonMsg.hpp](./plugin/JsonMsg.hpp)  
  Supports using types supported by [nlohmann/json](https://github.com/nlohmann/json) directly as message  
  (the `to_json/from_json` rules in `nlohmann/json` need to be satisfied).


* [Json.hpp](./plugin/Json.hpp)  
  A flexible way to use `nlohmann/json`

## Links

* Implementation based on asio: [asio_net](https://github.com/shuai132/asio_net)  
  Can be used on MCUs that support asio, such as ESP32.


* Implementation suitable for ESP8266: [esp_rpc](https://github.com/shuai132/esp_rpc)
