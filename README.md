# rpc_core

[![Build Status](https://github.com/shuai132/rpc_core/workflows/build/badge.svg)](https://github.com/shuai132/rpc_core/actions?workflow=build)

a tiny c++11 rpc library, supports all platforms (macOS, Linux, Windows, iOS, Android, etc.) and most microchips (
Arduino, STM32, ESP32/ESP8266, etc.)

## Introduction

The complete rpc frameworks (such as `gRPC` and `brpc`) have complex functions
and are not practical for use in embedded platforms.

This project offers a lightweight and user-friendly implementation that is better suited for one-to-one rpc calls.

It supports a wide range of microchips, including Arduino, STM32, ESP32/ESP8266, and more.

Note:
This project solely offers the protocol layer and API,
and `does not include the implementation of the transport layer`.
For TCP-based implementations, please refer to the [Links](#Links) section.

## Features

* Header-Only
* No schema
* Support performance-limited platforms, including MCUs
* Compatible with any connection type (serial port, TCP, etc.)
* RAII-based `dispose` for automatic request cancellation
* Timeout and retry settings
* Support `std::future` interface
* Customizable message types with implementations for `flatbuffers` and `json`
* Support automatic serialization of primitive types and most STL containers, and custom types by `RPC_CORE_DEFINE_TYPE`

## Requirements

* C++11
* Complete data packets are required for data transmission, such as WebSocket.  
  If using socket/serial port, etc.,
  message packing and unpacking need to be implemented by yourself. You can use:
  [PacketProcessor](https://github.com/shuai132/PacketProcessor)
  or
  [data_packer.hpp](https://github.com/shuai132/esp_rpc/blob/main/data_packer.hpp)

## Usage

```c++
// The Receiver
rpc->subscribe("cmd", [](const std::string& msg) -> std::string {
    assert(msg == "hello");
    return "world";
});

// The Sender
rpc->cmd("cmd")
    ->msg(std::string("hello"))
    ->rsp([](const std::string& rsp) {
      assert(rsp == "world");
    })
    ->call();
```

Detailed initialization process and unit tests can be found at: [rpc_test.cpp](test/rpc_test.cpp)

## Serialization

- [x] [std::string](https://en.cppreference.com/w/cpp/string/basic_string)
- [x] [std::wstring](https://en.cppreference.com/w/cpp/string/basic_string)
- [x] [std::array](https://en.cppreference.com/w/cpp/container/array)
- [x] [std::vector](https://en.cppreference.com/w/cpp/container/vector)
- [x] [std::list](https://en.cppreference.com/w/cpp/container/list)
- [x] [std::forward_list](https://en.cppreference.com/w/cpp/container/forward_list)
- [x] [std::deque](https://en.cppreference.com/w/cpp/container/deque)
- [x] [std::pair](https://en.cppreference.com/w/cpp/utility/pair)
- [x] [std::tuple](https://en.cppreference.com/w/cpp/utility/tuple)
- [x] [std::map](https://en.cppreference.com/w/cpp/container/map)
- [x] [std::unordered_map](https://en.cppreference.com/w/cpp/container/unordered_map)
- [x] [std::multimap](https://en.cppreference.com/w/cpp/container/multimap)
- [x] [std::unordered_multimap](https://en.cppreference.com/w/cpp/container/unordered_multimap)
- [x] [std::set](https://en.cppreference.com/w/cpp/container/set)
- [x] [std::unordered_set](https://en.cppreference.com/w/cpp/container/unordered_set)
- [x] [std::multiset](https://en.cppreference.com/w/cpp/container/multiset)
- [x] [std::unordered_multiset](https://en.cppreference.com/w/cpp/container/unordered_multiset)
- [x] [std::stack](https://en.cppreference.com/w/cpp/container/stack)
- [x] [std::queue](https://en.cppreference.com/w/cpp/container/queue)
- [x] [std::priority_queue](https://en.cppreference.com/w/cpp/container/priority_queue)
- [x] [std::bitset](https://en.cppreference.com/w/cpp/utility/bitset)
- [x] [std::complex](https://en.cppreference.com/w/cpp/numeric/complex)
- [x] [std::chrono::duration](https://en.cppreference.com/w/cpp/chrono/duration)
- [x] [std::chrono::time_point](https://en.cppreference.com/w/cpp/chrono/time_point)
- [x] [std::unique_ptr](https://en.cppreference.com/w/cpp/memory/unique_ptr)
- [x] [std::shared_ptr](https://en.cppreference.com/w/cpp/memory/shared_ptr)
- [x] [custom struct/class](test/type/CustomType.h)
  ```c++
  #include "src/serialize.hpp"
  struct TestStruct {
    uint8_t a;
    std::string b;
    OtherType c
    // RPC_CORE_DEFINE_TYPE_INNER(a, b, c);
  };
  RPC_CORE_DEFINE_TYPE(TestStruct, a, b, c);
  ```
  choose `RPC_CORE_DEFINE_TYPE` or `RPC_CORE_DEFINE_TYPE_INNER` for private member variable.

## Serialization Plugins

* [flatbuffers.hpp](./plugin/flatbuffers.hpp)  
  Supports using types generated by `flatbuffers` directly as message  
  (add the option `--gen-object-api` when using `flatc`)


* [json_msg.hpp](./plugin/json_msg.hpp)  
  Supports using types supported by [nlohmann/json](https://github.com/nlohmann/json) directly as message  
  (the `to_json/from_json` rules in `nlohmann/json` need to be satisfied, and use `DEFINE_JSON_CLASS`).


* [json.hpp](./plugin/json.hpp)  
  A flexible way to use `nlohmann/json`

## Links

* Implementation based on asio: [asio_net](https://github.com/shuai132/asio_net)  
  Can be used on MCUs that support asio, such as ESP32.


* Implementation suitable for ESP8266: [esp_rpc](https://github.com/shuai132/esp_rpc)
